import { ApiClient } from './ApiClient';
import { promptUser } from './CommandLineParser';
import { logger } from './Logger';
import { Video, Session } from './Types';

import { AxiosResponse } from 'axios';
import fs from 'fs';
import { parse } from 'iso8601-duration';
import path from 'path';
import sanitize from 'sanitize-filename';


function publishedDateToString(date: string): string {
    const dateJs: Date = new Date(date);
    const day: string = dateJs.getDate().toString().padStart(2, '0');
    const month: string = (dateJs.getMonth() + 1).toString(10).padStart(2, '0');

    return `${dateJs.getFullYear()}-${month}-${day}`;
}


function durationToTotalChunks(duration: string): number {
    const durationObj: any = parse(duration);
    const hrs: number = durationObj.hours ?? 0;
    const mins: number = durationObj.minutes ?? 0;
    const secs: number = Math.ceil(durationObj.seconds ?? 0);

    return (hrs * 60) + mins + (secs / 60);
}


export async function getVideoInfo(videoGuids: Array<string>, session: Session, subtitles?: boolean): Promise<Array<Video>> {
    let metadata: Array<Video> = [];
    let title: string;
    let date: string;
    let totalChunks: number;
    let playbackUrl: string;
    let posterImageUrl: string;
    let captionsUrl: string | undefined;

    const apiClient: ApiClient = ApiClient.getInstance(session);

    for (const GUID of videoGuids) {
        let response: AxiosResponse<any> | undefined= await apiClient.callApi('videos/' + GUID, 'get');

        title = sanitize(response?.data['name']);
        playbackUrl = response?.data['playbackUrls']
            .filter((item: { [x: string]: string; }) =>
                item['mimeType'] == 'application/vnd.apple.mpegurl')
            .map((item: { [x: string]: string }) => {
                return item['playbackUrl'];
            })[0];

        posterImageUrl = response?.data['posterImage']['medium']['url'];
        date = publishedDateToString(response?.data['publishedDate']);
        totalChunks = durationToTotalChunks(response?.data.media['duration']);

        if (subtitles) {
            let captions: AxiosResponse<any> | undefined = await apiClient.callApi(`videos/${GUID}/texttracks`, 'get');

            if (!captions?.data.value.length) {
                captionsUrl = undefined;
            }
            else if (captions?.data.value.length === 1) {
                logger.info(`Found subtitles for ${title}. \n`);
                captionsUrl = captions?.data.value.pop().url;
            }
            else {
                const index: number = promptUser(captions.data.value.map((item: { language: string; autoGenerated: string; }) => {
                    return `[${item.language}] autogenerated: ${item.autoGenerated}`;
                }));
                captionsUrl = captions.data.value[index].url;
            }
        }

        metadata.push({
            date: date,
            totalChunks: totalChunks,
            title: title,
            outPath: '',
            playbackUrl: playbackUrl,
            posterImageUrl: posterImageUrl,
            captionsUrl: captionsUrl
        });
    }

    return metadata;
}


export function createUniquePath(videos: Array<Video>, outDirs: Array<string>, format: string, skip?: boolean): Array<Video> {

    videos.forEach((video: Video, index: number) => {
        let title = `${video.title} - ${video.date}`;
        let i = 0;

        while (!skip && fs.existsSync(path.join(outDirs[index], title + '.' + format))) {
            title = `${video.title} - ${video.date}_${++i}`;
        }


        video.outPath = path.join(outDirs[index], title + '.' + format);
    });

    return videos;
}
